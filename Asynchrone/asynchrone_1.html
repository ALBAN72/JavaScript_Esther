<!DOCTYPE html>
<html>
	<head>
		<title>A simple performance counter</title>
		<script>

			//https://openclassrooms.com/fr/courses/5543061-ecrivez-du-javascript-pour-le-web/5577651-comprenez-comment-fonctionne-lasynchrone-en-js
			//Eh bien, tout simplement qu'il n'y a qu'un seul fil d'ex√©cution du code source.
			// Cela signifie que lorsque vous √©crivez du code, chaque ligne sera ex√©cut√©e l'une apr√®s
			// l'autre en attendant la fin de l'ex√©cution de la ligne pr√©c√©dente. Il n'y a pas d'autre code
			// qui pourra √™tre ex√©cut√© en parall√®le. Il ne peut faire qu'une seule chose √† la fois.

			//En fait il est possible et m√™me tr√®s facile de faire de l'asynchrone en JavaScript,
			// mais l'ex√©cution restera synchrone...
			//Si du code synchrone est du code qui s'ex√©cute ligne apr√®s ligne en attendant la fin de l'ex√©cution de la
			// ligne pr√©c√©dente, alors on peut facilement en d√©duire que du code asynchrone va s'ex√©cuter ligne apr√®s ligne,
			// mais la ligne suivante n'attendra pas que la ligne asynchrone ait fini son ex√©cution. Prenons cet exemple :

			//L'event loop

			//n JavaScript, chaque ligne de code est ex√©cut√©e de fa√ßon synchrone, mais il est possible de demander √† ex√©cuter du code
			// de mani√®re asynchrone. Et lorsque l'on demande √† ex√©cuter une fonction de fa√ßon asynchrone, la fonction en question est
			// plac√©e dans une sorte de file d'attente qui va ex√©cuter toutes les fonctions qu'elle contient les unes apr√®s les autres.
			// C'est ce qu'on appelle l'event loop. Tout le c≈ìur du langage fonctionne autour de √ßa.

			//Ainsi, le code n'est pas r√©ellement ex√©cut√© en parall√®le car il est mis en file d'attente, mais il ne bloque pas
			// l'ex√©cution du code depuis lequel il a √©t√© appel√©.


			//La fonction setTimeout  est la fonction la plus r√©pandue lorsque l'on veut ex√©cuter du code asynchrone sans bloquer
			// le fil d'ex√©cution en cours. Cette fonction prend 2 param√®tres :
			// La fonction √† ex√©cuter de mani√®re asynchrone (qui sera donc ajout√©e √† la file d'attente de l'event loop) ;
			// Le d√©lai, en millisecondes, avant d'ex√©cuter cette fonction.

			setTimeout(function() {
				console.log("I'm here!")
			}, 5000);

			console.log("Where are you?");


			//Il existe d'autres m√©thodes un peu moins r√©pandues, voire tr√®s peu utilis√©es :

			setInterval  (doc) : elle fonctionne exactement comme  setTimeout , √† ceci pr√®s qu'elle ex√©cute la fonction pass√©e en param√®tre en boucle √† une fr√©quence d√©termin√©e par le temps en millisecondes pass√© en second param√®tre. Il suffira de passer la valeur de retour de  setInterval  √†  clearInterval  pour stopper l'ex√©cution en boucle de la fonction ;

			setImmediate  (doc). Cette fonction prend en seul param√®tre la fonction √† ex√©cuter de fa√ßon synchrone.  La fonction en question sera plac√©e dans la file d'attente de l'event loop, mais va passer devant toutes les autres fonctions, sauf certaines sp√©cifiques au Javascript : les √©v√©nements (les m√™mes qu'on a vus au premier chapitre, et qui sont donc ex√©cut√©s de fa√ßon asynchrone  üòâ), le rendu, et l'I/O. Il existe aussi  nextTick , qui permet, l√†, de court-circuiter tout le monde. √Ä utiliser avec pr√©caution, donc...

		</script>
	</head>
	<body>
		Outputs to the console (press F12)
	</body>
</html>
